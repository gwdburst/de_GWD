#!/bin/bash
clear
red()    { echo -e "\033[31m\033[01m $1 \033[0m"; }
green()  { echo -e "\033[32m\033[01m $1 \033[0m"; }
yellow() { echo -e "\033[33m\033[01m $1 \033[0m"; }
blue()   { echo -e "\033[34m\033[01m $1 \033[0m"; }
purple() { echo -e "\033[35m\033[01m $1 \033[0m"; }
cyan()   { echo -e "\033[36m\033[01m $1 \033[0m"; }
white()  { echo -e "\033[37m\033[01m $1 \033[0m"; }
statusGOOD=$(green "✓")
statusBAD=$(red "✕")
statusNONE=$(yellow "-")
statusInstalled=$(green "[ installed ]")
statuSuccess=$(green "[    OK     ]")
statusFailed=$(red "[  failed   ]")
statusWarning=$(yellow "[  warning  ]")
statusUpdated=$(green "[  updated  ]")
virt_detect=$(systemd-detect-virt)
[[ -n $(echo "openvz lxc lxc-libvirt systemd-nspawn docker podman rkt wsl proot pouch" | grep $virt_detect) ]] && virt_type="container"
export DEBIAN_FRONTEND=noninteractive
architecture=$(dpkg --print-architecture)
piholeCoreRelease_reserved="v5.8.1"
piholeFTLRelease_reserved="v5.13"
piholeWebUIRelease_reserved="v5.10.1"
BBRPLUS_Ver="5.10.89"
branch="main"



checkSum(){
sha256sumL=$(sha256sum $1 2>/dev/null | awk '{print$1}')
if [[ $sha256sumL == $2 ]]; then 
  echo "true"
elif [[ $sha256sumL != $2 ]]; then
  echo "false"
fi
}



repoDL(){
sha256sum_don_server=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/doh/doh_s_"$architecture".sha256sum)
sha256sum_vtrui=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/vtrui_"$architecture".zip.sha256sum)
sha256sum_nginx=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/nginx/nginx_"$architecture".sha256sum)
sha256sum_nginxConf=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/nginx/nginxConf.zip.sha256sum)
sha256sum_sample=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/sample.zip.sha256sum)

if [[ $(checkSum /opt/de_GWD/doh-server $sha256sum_don_server) == "false" ]]; then
rm -rf /tmp/doh-server
wget --show-progress -t 5 -T 10 -cqO /tmp/doh-server https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/doh/doh_s_$architecture
[[ $(checkSum /tmp/doh-server $sha256sum_don_server) == "false" ]] && red "Download Failed" && exit
[[ $(checkSum /tmp/doh-server $sha256sum_don_server) == "true" ]] && mv -f /tmp/doh-server /opt/de_GWD/doh-server && chmod +x /opt/de_GWD/doh-server
fi

if [[ $(checkSum /usr/sbin/nginx $sha256sum_nginx) == "false" ]]; then
rm -rf /tmp/nginx
wget --show-progress -t 5 -T 10 -cqO /tmp/nginx https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/nginx/nginx_"$architecture"
[[ $(checkSum /tmp/nginx $sha256sum_nginx) == "false" ]] && red "Download Failed" && exit
[[ $(checkSum /tmp/nginx $sha256sum_nginx) == "true" ]] && mv -f /tmp/nginx /usr/sbin/nginx && chmod +x /usr/sbin/nginx
fi

if [[ $(checkSum /opt/de_GWD/.repo/vtrui.zip $sha256sum_vtrui) == "false" ]]; then
rm -rf /tmp/vtrui.zip
wget --show-progress -t 5 -T 10 -cqO /tmp/vtrui.zip https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/vtrui_"$architecture".zip
[[ $(checkSum /tmp/vtrui.zip $sha256sum_vtrui) == "false" ]] && red "Download Failed" && exit
[[ $(checkSum /tmp/vtrui.zip $sha256sum_vtrui) == "true" ]] && mv -f /tmp/vtrui.zip /opt/de_GWD/.repo/vtrui.zip
fi

if [[ $(checkSum /opt/de_GWD/.repo/nginxConf.zip $sha256sum_nginxConf) == "false" ]]; then
rm -rf /tmp/nginxConf.zip
wget --show-progress -t 5 -T 10 -cqO /tmp/nginxConf.zip https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/nginx/nginxConf.zip
[[ $(checkSum /tmp/nginxConf.zip $sha256sum_nginxConf) == "false" ]] && red "Download Failed" && exit
[[ $(checkSum /tmp/nginxConf.zip $sha256sum_nginxConf) == "true" ]] && mv -f /tmp/nginxConf.zip /opt/de_GWD/.repo/nginxConf.zip
fi

if [[ $(checkSum /opt/de_GWD/.repo/sample.zip $sha256sum_sample) == "false" ]]; then
rm -rf /tmp/sample.zip
wget --show-progress -t 5 -T 10 -cqO /tmp/sample.zip https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/sample.zip
[[ $(checkSum /tmp/sample.zip $sha256sum_sample) == "false" ]] && red "Download Failed" && exit
[[ $(checkSum /tmp/sample.zip $sha256sum_sample) == "true" ]] && mv -f /tmp/sample.zip /opt/de_GWD/.repo/sample.zip
fi

localVer=$(awk 'NR==1' /opt/de_GWD/version.php 2>/dev/null)
remoteVer=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/main/version.php | head -n 1)

if [[ $localVer != $remoteVer ]]; then
rm -rf /tmp/version.php
wget --show-progress -t 5 -T 10 -cqO /tmp/version.php https://raw.githubusercontent.com/jacyl4/de_GWD/main/version.php
[[ $? -ne 0 ]] && red "Download Failed" && exit
[[ $(du -sk /tmp/version.php 2>/dev/null | awk '{print$1}') -ge 4 ]] && mv -f /tmp/version.php /opt/de_GWD/version.php
fi

echo -n "$statusUpdated" && white "Repository"
}



preUpdate(){
if [[ -d /usr/local/bin/vtrui ]]; then
mv -f /usr/local/bin/vtrui /opt/de_GWD/vtrui
fi

if [[ -d "/opt/AdGuardHome" ]]; then
  systemctl stop AdGuardHome >/dev/null 2>&1
  rm -rf /etc/systemd/system/AdGuardHome.service
  rm -rf /lib/systemd/system/AdGuardHome.service
  rm -rf /opt/AdGuardHome
  rm -rf /usr/bin/yq
fi

if [[ -f "/lib/systemd/system/frps.service" ]] || [[ -f "/lib/systemd/system/frpc.service" ]]; then
  systemctl disable frps >/dev/null 2>&1
  systemctl disable frpc >/dev/null 2>&1
  systemctl stop frps >/dev/null 2>&1
  systemctl stop frpc >/dev/null 2>&1
  rm -rf /etc/systemd/system/frps.service >/dev/null 2>&1
  rm -rf /lib/systemd/system/frps.service >/dev/null 2>&1
  rm -rf /etc/systemd/system/frpc.service >/dev/null 2>&1
  rm -rf /lib/systemd/system/frpc.service >/dev/null 2>&1
  systemctl daemon-reload >/dev/null
  rm -rf /opt/de_GWD/frps
  rm -rf /opt/de_GWD/frpc
fi

if [[  -f "/opt/de_GWD/iptablesrules-up" ]]; then
  systemctl disable iptablesrules >/dev/null 2>&1
  systemctl stop iptablesrules >/dev/null 2>&1
  rm -rf /etc/systemd/system/iptablesrules.service >/dev/null 2>&1
  rm -rf /lib/systemd/system/iptablesrules.service >/dev/null 2>&1
  systemctl daemon-reload >/dev/null
  rm -rf /opt/de_GWD/iptablesrules-down
  rm -rf /opt/de_GWD/iptablesrules-up
  rm -rf /opt/de_GWD/Q4amSun
fi

[[ ! -f "/var/www/ssl/de_GWD.cer" ]] && mv -f /var/www/ssl/*.cer /var/www/ssl/de_GWD.cer && sed -i '/ssl_certificate /c\ssl_certificate \/var\/www\/ssl\/de_GWD.cer;' /etc/nginx/conf.d/default.conf
[[ ! -f "/var/www/ssl/de_GWD.key" ]] && mv -f /var/www/ssl/*.key /var/www/ssl/de_GWD.key && sed -i '/ssl_certificate_key /c\ssl_certificate_key \/var\/www\/ssl\/de_GWD.key;' /etc/nginx/conf.d/default.conf

[[ -f "/etc/nginx/conf.d/merge.sh" ]] && rm -rf /etc/nginx/conf.d/*

[[ -n $(dpkg -l | awk '{print$2}' | grep '^ipset$') ]] && apt --purge remove ipset

rm -rf /opt/de_GWD/.repo/IPchnroute
rm -rf /usr/local/bin/autoUpdate
rm -rf /usr/local/bin/iptablesrules*
rm -rf /usr/local/bin/Q2H
rm -rf /usr/local/bin/version.php
rm -rf /usr/local/bin/vtrui
rm -rf /usr/bin/yq
rm -rf /etc/dns-over-https
rm -rf /etc/nginx/conf.d/0_serverUpstream
rm -rf /etc/nginx/conf.d/4_v2Proxy
rm -rf /etc/ld.so.preload
rm -rf /dev/shm/de_GWD.socket*

crontab -l 2>/dev/null >/tmp/now.cron
sed -i '/\/usr\/local\/bin\/.*/d' /tmp/now.cron
sed -i '/\/var\/www\/ssl\/update_ocsp_cache/d' /tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron



service cron stop

ethernetnum=$(ip --oneline link show up | grep -v "lo" | awk '{print$2;exit}' | cut -d':' -f1 | cut -d'@' -f1)
ethernetnums=$(ip --oneline link show up | grep -v "lo" | awk '{print $2}' | cut -d':' -f1 | cut -d'@' -f1 | xargs | sed 's/ /,/g')
localaddr=$(ip -4 a | grep inet | grep -v 127.0.0 | awk '{print $2}' | cut -d'/' -f1 | head -n 1)

domain=$(awk '/server_name/ {print$2;exit}' /etc/nginx/conf.d/default.conf | sed 's/.$//')
topDomain=$(echo $domain | rev | awk -F. '{print $1"."$2}' | rev)
port=$(awk '/ssl http2 fastopen=128 reuseport/ {print$2}' /etc/nginx/conf.d/default.conf | grep '^[[:digit:]]*$')
[[ -z $port ]] && port="443"

path=$(jq -r '.inbounds[0].streamSettings.wsSettings.path' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
uuids=$(jq -r '.inbounds[0].settings.clients[].id' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')

upDomain=$(jq -r '.outbounds[0].settings.vnext[0].address' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
upPort=$(jq -r '.outbounds[0].settings.vnext[0].port' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
upUUID=$(jq -r '.outbounds[0].settings.vnext[0].users[0].id' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
xtlsPort=$(jq -r '.inbounds[] | select(.tag == "forward") | .port' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
}



preInstall(){
sync; echo 3 >/proc/sys/vm/drop_caches >/dev/null 2>&1

if [[ -n "$(ps -e | grep 'pihole-FTL' )" ]]; then
cat << EOF >/etc/dnsmasq.conf
conf-dir=/etc/dnsmasq.d
listen-address=127.0.0.1
port=0
EOF
pihole restartdns
fi

rm -rf /etc/resolv.conf
cat << EOF >/etc/resolv.conf
nameserver 1.1.1.1
nameserver 8.8.8.8
EOF

if [[ $(free -m | awk 'NR==3{print$2}') = "0" ]] && [[ $virt_type != "container" ]]; then
fallocate -l 1G /swapfile
dd if=/dev/zero of=/swapfile bs=1k count=1024k status=progress
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile
sed -i "/swapfile/d" /etc/fstab
echo "/swapfile swap swap defaults 0 0" >>/etc/fstab
echo "RESUME=" >/etc/initramfs-tools/conf.d/resume
fi

mkdir -p /opt/de_GWD
mkdir -p /opt/de_GWD/.repo
cat << "EOF" >/opt/de_GWD/tcpTime
date -s "$(wget -qSO- --max-redirect=0 whatismyip.akamai.com 2>&1 | grep Date: | cut -d' ' -f5-8)Z" | grep -v ' 08:00:00 '
[[ $? -ne "0" ]]&& date -s "$(wget -qSO- --max-redirect=0 ifconfig.me 2>&1 | grep Date: | cut -d' ' -f5-8)Z"
hwclock -w
EOF
chmod +x /opt/de_GWD/tcpTime
[[ $virt_type != "container" ]] && /opt/de_GWD/tcpTime

cat << EOF >/etc/apt/apt.conf.d/01InstallLess
APT::Get::Assume-Yes "true";
APT::Install-Recommends "false";
APT::Install-Suggests "false";
EOF

cat << EOF >/etc/apt/apt.conf.d/71debconf
Dpkg::Options {
   "--force-confdef";
   "--force-confold";
};
EOF

source /etc/profile
cat << EOF >~/.bash_profile
PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'

ulimit -n 1000000
HISTCONTROL=ignoredups

alias reboot="sudo systemctl reboot"
EOF
source ~/.bash_profile

cat << EOF >/etc/security/limits.conf
* soft nofile 1000000
* hard nofile 1000000
root soft nofile 1000000
root hard nofile 1000000
* soft nproc unlimited
* hard nproc unlimited
root soft nproc unlimited
root hard nproc unlimited
* soft core unlimited
* hard core unlimited
root soft core unlimited
root hard core unlimited
EOF

dpkg --configure -a

cat << EOF >/etc/apt/sources.list
deb http://cloudfront.debian.net/debian bullseye main contrib non-free
deb http://cloudfront.debian.net/debian bullseye-updates main contrib non-free
deb http://cloudfront.debian.net/debian bullseye-backports main contrib non-free
deb http://cloudfront.debian.net/debian-security bullseye-security main contrib non-free
EOF

apt update --fix-missing && apt upgrade --allow-downgrades -y
apt full-upgrade -y && apt --purge autoremove -y && apt clean -y && apt autoclean -y

unset aptPKG
[[ -z $(dpkg -l | awk '{print$2}' | grep '^sudo$') ]] && aptPKG+=(sudo)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^locales$') ]] && aptPKG+=(locales)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^netcat$') ]] && aptPKG+=(netcat)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^dnsutils$') ]] && aptPKG+=(dnsutils)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^net-tools$') ]] && aptPKG+=(net-tools)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^resolvconf$') ]] && aptPKG+=(resolvconf)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^nftables$') ]] && aptPKG+=(nftables)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^wget$') ]] && aptPKG+=(wget)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^curl$') ]] && aptPKG+=(curl)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^git$') ]] && aptPKG+=(git)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^ca-certificates$') ]] && aptPKG+=(ca-certificates)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^apt-transport-https$') ]] && aptPKG+=(apt-transport-https)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^gnupg2$') ]] && aptPKG+=(gnupg2)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^unzip$') ]] && aptPKG+=(unzip)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^jq$') ]] && aptPKG+=(jq)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^bc$') ]] && aptPKG+=(bc)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^moreutils$') ]] && aptPKG+=(moreutils)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^haveged$') ]] && aptPKG+=(haveged)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^socat$') ]] && aptPKG+=(socat)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^ethtool$') ]] && aptPKG+=(ethtool)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^screen$') ]] && aptPKG+=(screen)
[[ -z $(dpkg -l | awk '{print$2}' | grep '^qrencode$') ]] && aptPKG+=(qrencode)
[[ -n $aptPKG ]] && apt install $(echo ${aptPKG[@]})

systemctl enable --now haveged >/dev/null 2>&1
systemctl mask --now systemd-resolved  >/dev/null 2>&1
systemctl daemon-reload >/dev/null

[[ -n $(which setenforce) ]] && setenforce 0
[[ -f "/etc/selinux/config" ]] && sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config

if [[ -n $(dpkg -l | awk '{print$2}' | grep '^docker-ce$') ]] && [[ -n $(dpkg -l | awk '{print$2}' | grep '^containerd.io$') ]] && [[ ! -f "/etc/docker/daemon.json" ]]; then
mkdir -p /etc/docker/
systemctl stop docker containerd
cat << EOF >/etc/docker/daemon.json
{
  "iptables": false
}
EOF
systemctl restart docker
fi

DPKGclean=$(dpkg --list | grep "^rc" | cut -d " " -f 3)
[[ -n $DPKGclean ]] && echo $DPKGclean | xargs sudo dpkg --purge

rm -rf /var/log/journal/*

export LANG=en_US.UTF-8
export LANGUAGE=en_US.UTF-8
export LC_CTYPE=en_US.UTF-8
export LC_ALL=en_US.UTF-8
localeSet=`cat << EOF
LANG=en_US.UTF-8
LANGUAGE=en_US.UTF-8
LC_CTYPE="en_US.UTF-8"
LC_NUMERIC="en_US.UTF-8"
LC_TIME="en_US.UTF-8"
LC_COLLATE="en_US.UTF-8"
LC_MONETARY="en_US.UTF-8"
LC_MESSAGES="en_US.UTF-8"
LC_PAPER="en_US.UTF-8"
LC_NAME="en_US.UTF-8"
LC_ADDRESS="en_US.UTF-8"
LC_TELEPHONE="en_US.UTF-8"
LC_MEASUREMENT="en_US.UTF-8"
LC_IDENTIFICATION="en_US.UTF-8"
LC_ALL=en_US.UTF-8
EOF
`
if [[ $(locale) != "$localeSet" ]]; then
echo "$localeSet" >/etc/default/locale
echo "en_US.UTF-8 UTF-8" >/etc/locale.gen
locale-gen en_US.UTF-8 UTF-8
update-locale en_US.UTF-8 UTF-8
fi

if [[ $(date +"%Z %z") != "CST +0800" ]]; then
echo "Asia/Shanghai" >/etc/timezone
ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
fi

if [[ $virt_type != "container" ]]; then
modprobe nf_conntrack
sed -i '/nf_conntrack/d' /etc/modules-load.d/modules.conf
sed -i '/xt_conntrack/d' /etc/modules-load.d/modules.conf
sed -i '/ip_conntrack/d' /etc/modules-load.d/modules.conf
sed -i '/nf_nat/d' /etc/modules-load.d/modules.conf
sed -i '/xt_nat/d' /etc/modules-load.d/modules.conf
cat << EOF >>/etc/modules-load.d/modules.conf
nf_conntrack
EOF

cat << EOF >/etc/sysctl.conf
vm.overcommit_memory = 1
vm.swappiness = 10
vm.dirty_ratio = 10
vm.dirty_background_ratio = 5
fs.nr_open = 1000000
fs.file-max = 1000000
fs.inotify.max_user_instances = 819200
fs.inotify.max_queued_events = 32000
fs.inotify.max_user_watches = 64000
net.unix.max_dgram_qlen = 1024
net.nf_conntrack_max = 131072
net.netfilter.nf_conntrack_acct = 0
net.netfilter.nf_conntrack_checksum = 0
net.netfilter.nf_conntrack_events = 1
net.netfilter.nf_conntrack_timestamp = 1
net.netfilter.nf_conntrack_helper = 1
net.netfilter.nf_conntrack_max = 16384
net.netfilter.nf_conntrack_buckets = 65536
net.netfilter.nf_conntrack_tcp_loose = 1
net.netfilter.nf_conntrack_tcp_be_liberal = 1
net.netfilter.nf_conntrack_tcp_max_retrans = 3
net.netfilter.nf_conntrack_generic_timeout = 60
net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 30
net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 30
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 30
net.netfilter.nf_conntrack_tcp_timeout_close_wait = 15
net.netfilter.nf_conntrack_tcp_timeout_close = 5
net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30
net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 30
net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 30
net.netfilter.nf_conntrack_tcp_timeout_established = 3600
net.netfilter.nf_conntrack_sctp_timeout_established = 3600
net.netfilter.nf_conntrack_udp_timeout = 15
net.netfilter.nf_conntrack_udp_timeout_stream = 45
net.core.somaxconn = 65535
net.core.optmem_max = 4194304
net.core.netdev_max_backlog = 300000
net.core.rmem_default = 4194304
net.core.rmem_max = 4194304
net.core.wmem_default = 4194304
net.core.wmem_max = 4194304
net.ipv4.conf.all.arp_accept = 0
net.ipv4.conf.default.arp_accept = 0
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.default.arp_ignore = 1
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.ip_forward = 0
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.ip_no_pmtu_disc = 0
net.ipv4.route.gc_timeout = 100
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1
net.ipv4.udp_rmem_min = 16384
net.ipv4.udp_wmem_min = 16384
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_base_mss = 1024
net.ipv4.tcp_mtu_probe_floor = 48
net.ipv4.tcp_min_snd_mss = 48
net.ipv4.tcp_probe_interval = 600
net.ipv4.tcp_probe_threshold = 8
net.ipv4.tcp_min_tso_segs = 2
net.ipv4.tcp_tso_win_divisor = 3
net.ipv4.tcp_moderate_rcvbuf = 1
net.ipv4.tcp_app_win = 31
net.ipv4.tcp_adv_win_scale = 1
net.ipv4.tcp_mem = 181419 241895 362838
net.ipv4.tcp_rmem = 8192 87380 6291456
net.ipv4.tcp_wmem = 8192 65536 4194304
net.ipv4.tcp_max_tw_buckets = 60000
net.ipv4.tcp_max_syn_backlog = 32768
net.ipv4.tcp_max_orphans = 32768
net.ipv4.tcp_abort_on_overflow = 0
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_workaround_signed_windows = 0
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.tcp_no_ssthresh_metrics_save = 1
net.ipv4.tcp_fwmark_accept = 0
net.ipv4.tcp_invalid_ratelimit = 500
net.ipv4.tcp_ecn = 0
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_fastopen_key = 00000000-00000000-00000000-00000000
net.ipv4.tcp_fastopen_blackhole_timeout_sec = 0
net.ipv4.tcp_thin_linear_timeouts = 0
net.ipv4.tcp_keepalive_time = 1800
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 6
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_tw_reuse = 2
net.ipv4.tcp_fin_timeout = 60
net.ipv4.tcp_rfc1337 = 1
net.ipv4.tcp_orphan_retries = 2
net.ipv4.tcp_syn_retries = 3
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_retries1 = 3
net.ipv4.tcp_retries2 = 8
net.ipv4.tcp_sack = 1
net.ipv4.tcp_dsack = 1
net.ipv4.tcp_fack = 0
net.ipv4.tcp_challenge_ack_limit=100000000
net.ipv4.tcp_frto = 0
net.ipv4.tcp_recovery = 1
net.ipv4.tcp_reordering = 3
net.ipv4.tcp_early_retrans = 3
net.ipv4.tcp_retrans_collapse = 1
net.ipv4.tcp_autocorking = 1
net.ipv4.tcp_slow_start_after_idle = 0
EOF

sed -i "/net.core.default_qdisc/d" /etc/sysctl.conf
sed -i '/net.ipv4.tcp_congestion_control/d' /etc/sysctl.conf

if [[ $(uname -r) =~ "bbrplus" ]]; then
  echo "net.core.default_qdisc = fq_codel" >>/etc/sysctl.conf
  echo "net.ipv4.tcp_congestion_control = bbrplus" >>/etc/sysctl.conf
else
  echo "net.core.default_qdisc = fq_codel" >>/etc/sysctl.conf
  echo "net.ipv4.tcp_congestion_control = bbr" >>/etc/sysctl.conf
fi
sysctl -p >/dev/null
systemctl restart systemd-sysctl
fi
}



piholeConf(){
cat << EOF >/etc/pihole/setupVars.conf
WEBPASSWORD=0000000000000000000000000000000000000000000000000000000000000000
IPV4_ADDRESS=$localaddr/24
PIHOLE_DNS_1=1.1.1.1
PIHOLE_DNS_2=8.8.8.8
PIHOLE_DNS_3=1.0.0.1
PIHOLE_DNS_4=8.8.4.4
PIHOLE_DNS_5=208.67.222.222
PIHOLE_DNS_6=208.67.220.220
DNSMASQ_LISTENING=local
QUERY_LOGGING=false
INSTALL_WEB_SERVER=false
INSTALL_WEB_INTERFACE=false
LIGHTTPD_ENABLED=false
BLOCKING_ENABLED=true
DNS_FQDN_REQUIRED=true
DNS_BOGUS_PRIV=true
DNSSEC=false
REV_SERVER=false
EOF
}



installPihole(){
rm -rf /etc/resolv.conf
cat << EOF >/etc/resolv.conf
nameserver 1.1.1.1
nameserver 8.8.8.8
EOF

piholeCoreRelease=$(curl -kLs "https://api.github.com/repos/pi-hole/pi-hole/releases/latest" | jq -r '.tag_name' | grep -v '^null$')
piholeFTLRelease=$(curl -kLs "https://api.github.com/repos/pi-hole/FTL/releases/latest" | jq -r '.tag_name' | grep -v '^null$')

[[ -z $piholeCoreRelease ]] && piholeCoreRelease=$piholeCoreRelease_reserved
[[ -z $piholeFTLRelease ]] && piholeFTLRelease=$piholeFTLRelease_reserved

piholeCoreVer=$(awk '{print$1}' /etc/pihole/localversions 2>/dev/null | grep -Po "^v(\d+\.)+\d+")
piholeFTLVer=$(awk '{print$2}' /etc/pihole/localversions 2>/dev/null | grep -Po "^v(\d+\.)+\d+")

[[ $piholeCoreVer == $piholeCoreRelease ]] && [[ $piholeFTLVer == $piholeFTLRelease ]] && [[ $(systemctl is-active 'pihole-FTL') == "active" ]] && return

export PIHOLE_SKIP_OS_CHECK=true
rm -rf /etc/.pihole /etc/pihole /opt/pihole /usr/bin/pihole-FTL /usr/local/bin/pihole /var/www/html/pihole /var/www/html/admin
systemctl unmask dhcpcd >/dev/null 2>&1
mkdir -p /etc/pihole
>/etc/pihole/adlists.list

piholeConf

git clone https://github.com/pi-hole/pi-hole /etc/.pihole
curl -fsSL https://install.pi-hole.net | bash /dev/stdin --unattended
}



piholeSet(){
systemctl disable --now lighttpd >/dev/null 2>&1
systemctl disable --now dhcpcd >/dev/null 2>&1
systemctl mask --now lighttpd >/dev/null 2>&1
systemctl mask --now dhcpcd >/dev/null 2>&1
systemctl daemon-reload >/dev/null

rm -rf /etc/resolvconf/resolv.conf.d/*
>/etc/resolvconf/resolv.conf.d/original
>/etc/resolvconf/resolv.conf.d/base
>/etc/resolvconf/resolv.conf.d/tail
rm -rf /etc/resolv.conf
rm -rf /run/resolvconf/interface
cat << EOF >/etc/resolvconf/resolv.conf.d/head
nameserver 127.0.0.1
EOF
if [[ -f "/etc/resolvconf/run/resolv.conf" ]]; then
ln -sf /etc/resolvconf/run/resolv.conf /etc/resolv.conf
elif [[ -f "/run/resolvconf/resolv.conf" ]]; then
ln -sf /run/resolvconf/resolv.conf /etc/resolv.conf
fi
resolvconf -u

piholeConf

cat << EOF >/etc/pihole/pihole-FTL.conf
BLOCKINGMODE=NULL
CNAME_DEEP_INSPECT=true
BLOCK_ESNI=true
EDNS0_ECS=true
RATE_LIMIT=0/0
REPLY_WHEN_BUSY=ALLOW

MAXLOGAGE=24.0
PRIVACYLEVEL=0
IGNORE_LOCALHOST=no
AAAA_QUERY_ANALYSIS=yes
ANALYZE_ONLY_A_AND_AAAA=false
SHOW_DNSSEC=true

SOCKET_LISTENING=localonly
FTLPORT=4711
RESOLVE_IPV6=no
RESOLVE_IPV4=yes
PIHOLE_PTR=PI.HOLE
DELAY_STARTUP=0
NICE=-10
MAXNETAGE=30
NAMES_FROM_NETDB=true
REFRESH_HOSTNAMES=IPV4
PARSE_ARP_CACHE=true
CHECK_LOAD=false
CHECK_SHMEM=90
CHECK_DISK=90 

DBIMPORT=yes
MAXDBDAYS=30
DBINTERVAL=1.0
DBFILE=/etc/pihole/pihole-FTL.db
EOF

rm -rf /etc/dnsmasq.conf.old
cat << EOF >/etc/dnsmasq.conf
conf-dir=/etc/dnsmasq.d
dns-forward-max=1000
EOF
pihole restartdns

/opt/pihole/updatecheck.sh
}



installNftables(){
mkdir -p /opt/de_GWD/nftables
cat << EOF >/opt/de_GWD/nftables/default.nft
#!/usr/sbin/nft -f
table inet filter {
        chain input {
                type filter hook input priority 0;
                iifname lo accept
                ct state established,related accept
                tcp flags != syn ct state new drop
                tcp flags & (fin|syn) == (fin|syn) drop
                tcp flags & (syn|rst) == (syn|rst) drop
                tcp flags & (fin|syn|rst|psh|ack|urg) < (fin) drop
                tcp flags & (fin|syn|rst|psh|ack|urg) == (fin|psh|urg) drop
                ct state invalid counter drop
                # Drop 53 in
                tcp dport 53 iifname $ethernetnum drop
                udp dport 53 iifname $ethernetnum drop
        }
        chain forward {
                type filter hook forward priority 0;
                # Docker traffic
                counter jump DOCKER-USER
                counter jump DOCKER-ISOLATION-STAGE-1
                oifname docker0 ct state established,related counter accept
                oifname docker0 counter jump DOCKER
                iifname docker0 oifname != docker0 counter accept
                iifname docker0 oifname docker0 counter accept
        }
        chain output {
                type filter hook output priority 0;
                oifname lo accept
        }
        chain DOCKER {
        }
        chain DOCKER-USER {
                counter return
        }
        chain DOCKER-ISOLATION-STAGE-1 {
                iifname docker0 oifname != docker0 counter jump DOCKER-ISOLATION-STAGE-2
                counter return
        }
        chain DOCKER-ISOLATION-STAGE-2 {
                oifname docker0 counter drop
                counter return
        }
}

table ip router {
        chain prerouting {
                type nat hook prerouting priority 0;
                #Docker
                fib daddr type local counter jump DOCKER
        }
        chain postrouting {
                type nat hook postrouting priority 0;
                # Docker
                oifname != docker0 ip saddr 172.17.0.0/16 counter masquerade
        }
        chain input {
                type nat hook input priority 0;
        }
        chain output {
                type nat hook output priority 0;
                ip daddr != 127.0.0.0/8 fib daddr type local counter jump DOCKER
        }
        chain DOCKER {
                iifname docker0 counter return
        }
}
EOF
chmod +x /opt/de_GWD/nftables/default.nft

rm -rf /lib/systemd/system/nftables.service
cat << EOF >/etc/systemd/system/nftables.service
[Unit]
Description=nftables
Wants=network-pre.target
Before=network-pre.target shutdown.target
Conflicts=shutdown.target
DefaultDependencies=no

[Service]
User=root
Type=oneshot
RemainAfterExit=yes
StandardInput=null
ProtectSystem=full
ProtectHome=true
ExecStart=/usr/sbin/nft -f /opt/de_GWD/nftables/default.nft
ExecStop=/usr/sbin/nft flush ruleset

[Install]
WantedBy=sysinit.target
EOF
ln -sf /etc/systemd/system/nftables.service /lib/systemd/system/nftables.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null
systemctl restart nftables
systemctl enable nftables >/dev/null 2>&1
}



installDOH(){
cat << EOF >/opt/de_GWD/doh-server.conf
listen = [ "127.0.0.1:8053" ]
path = "/dq"
upstream = [ "udp:127.0.0.1:53" ]
timeout = 10
tries = 3
verbose = false
log_guessed_client_ip = false
ecs_allow_non_global_ip = false
ecs_use_precise_ip = false
EOF

mkdir -p /etc/NetworkManager/dispatcher.d
cat << "EOF" > /etc/NetworkManager/dispatcher.d/doh-server
#!/bin/bash
case "$2" in
    up)
        /usr/bin/systemctl is-active doh-server.service >/dev/null && /usr/bin/systemctl restart doh-server.service
        ;;
    down)
        /usr/bin/systemctl is-active doh-server.service >/dev/null && /usr/bin/systemctl restart doh-server.service
        ;;
    *)
        exit 0
        ;;
esac
EOF
chmod +x /etc/NetworkManager/dispatcher.d/doh-server

rm -rf /lib/systemd/system/doh-server.service
cat << "EOF" >/etc/systemd/system/doh-server.service
[Unit]
Description=DNS-over-HTTPS server
After=network.target

[Service]
User=root
Type=simple
ExecStart=/opt/de_GWD/doh-server -conf /opt/de_GWD/doh-server.conf
Restart=on-failure
LimitNOFILE=1000000
LimitNPROC=infinity
LimitCORE=infinity
NoNewPrivileges=true
Nice=-9

[Install]
WantedBy=multi-user.target
EOF

if [[ $virt_type == "container" ]]; then
sed -i '/Nice=/d' /etc/systemd/system/doh-server.service
fi
ln -sf /etc/systemd/system/doh-server.service /lib/systemd/system/doh-server.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null

echo -n "$statuSuccess" && white "Install DoH Server"
}



installXray(){
mkdir -p /opt/de_GWD/vtrui

if [[ $(unzip -tq /opt/de_GWD/.repo/vtrui.zip 2>/dev/null) =~ "No errors" ]]; then
rm -rf /tmp/vtrui
unzip /opt/de_GWD/.repo/vtrui.zip -d /tmp/vtrui >/dev/null 2>&1
mv -f /tmp/vtrui/xray /opt/de_GWD/vtrui/vtrui
chmod +x /opt/de_GWD/vtrui/vtrui
rm -rf /tmp/vtrui*
else
rm -rf /opt/de_GWD/.repo/vtrui.zip
red "Download Failed" && exit
fi

rm -rf /lib/systemd/system/vtrui.service
cat << EOF >/etc/systemd/system/vtrui.service
[Unit]
Description=vtrui
After=network.target nss-lookup.target

[Service]
User=www-data
Type=simple
ExecStartPre=$(which rm) -rf /dev/shm/de_GWD.socket*
ExecStart=/opt/de_GWD/vtrui/vtrui -c /opt/de_GWD/vtrui/config.json
ExecStopPost=$(which rm) -rf /dev/shm/de_GWD.socket*
Restart=on-failure
CapabilityBoundingSet=CAP_NET_RAW CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN CAP_NET_BIND_SERVICE
LimitNOFILE=1000000
LimitNPROC=infinity
LimitCORE=infinity
NoNewPrivileges=true
Nice=-8

[Install]
WantedBy=multi-user.target
EOF

if [[ $virt_type == "container" ]]; then
sed -i '/Nice=/d' /etc/systemd/system/vtrui.service
fi
ln -sf /etc/systemd/system/vtrui.service /lib/systemd/system/vtrui.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null

echo -n "$statuSuccess" && white "Install Xray"
}



installNginx(){
mkdir -p "/etc/nginx"
mkdir -p "/etc/nginx/conf.d"
mkdir -p "/var/www/html"
mkdir -p "/var/www/ssl"
mkdir -p "/var/log/nginx"
mkdir -p "/var/cache/nginx/client_temp"
mkdir -p "/var/cache/nginx/proxy_temp"
mkdir -p "/var/cache/nginx/fastcgi_temp"
mkdir -p "/var/cache/nginx/scgi_temp"
mkdir -p "/var/cache/nginx/uwsgi_temp"

if [[ $(unzip -tq /opt/de_GWD/.repo/nginxConf.zip 2>/dev/null) =~ "No errors" ]]; then
rm -rf /tmp/nginxConf
unzip /opt/de_GWD/.repo/nginxConf.zip -d /tmp >/dev/null
mv -f /tmp/nginxConf/* /etc/nginx
rm -rf /tmp/nginxConf
else
rm -rf /opt/de_GWD/.repo/nginxConf.zip
red "Download Failed" && exit
fi

rm -rf /lib/systemd/system/nginx.service
cat << EOF >/etc/systemd/system/nginx.service
[Unit]
Description=NGINX
After=network.target

[Service]
Type=forking
PIDFile=/run/nginx.pid
ExecStartPre=/usr/sbin/nginx -t
ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf
ExecReload=/usr/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT \$MAINPID
ExecStopPost=$(which rm) -f /run/nginx.pid
KillMode=process
Restart=on-failure
AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN CAP_NET_BIND_SERVICE
LimitNOFILE=1000000
LimitNPROC=infinity
LimitCORE=infinity
PrivateTmp=false
NoNewPrivileges=yes
Nice=-5

[Install]
WantedBy=multi-user.target
EOF
mkdir -p "/etc/systemd/system/nginx.service.d"
printf "[Service]\nExecStartPost=/bin/sleep 0.1\n" >/etc/systemd/system/nginx.service.d/override.conf

if [[ $virt_type == "container" ]]; then
sed -i '/Nice=/d' /etc/systemd/system/nginx.service
fi

ln -sf /etc/systemd/system/nginx.service /lib/systemd/system/nginx.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null

echo -n "$statuSuccess" && white "Install NGINX"
}



makeSSL_D(){
crontab -l 2>/dev/null >/tmp/now.cron
sed -i '/acme.sh/d' /tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron
rm -rf "/root/.acme.sh"

export CF_Key="$CFapikey"
export CF_Email="$CFemail"

if [[ $(systemctl is-active 'nginx') != "active" ]]; then
  systemctl restart nginx
  if [[ $? -ne 0 ]]; then
  sed -i '/Nice=/d' /etc/systemd/system/nginx.service
  ln -sf /etc/systemd/system/nginx.service /lib/systemd/system/nginx.service >/dev/null 2>&1
  systemctl daemon-reload >/dev/null
  systemctl restart nginx
  fi
else
systemctl force-reload nginx
fi

rm -rf /var/www/ssl/*.cer
rm -rf /var/www/ssl/*.key
[[ -f "/var/www/ssl/bundle.pem" ]] && ls /var/www/ssl/*.pem | xargs -n 1 | grep -v "dhparam.pem" | while read line
do
rm -rf $line
done

[[ ! -f "/var/www/ssl/dhparam.pem" ]] && openssl dhparam -out /var/www/ssl/dhparam.pem 2048

curl https://get.acme.sh | sh
"/root/.acme.sh"/acme.sh --upgrade  --auto-upgrade
"/root/.acme.sh"/acme.sh --set-default-ca  --server letsencrypt
"/root/.acme.sh"/acme.sh --issue --dns dns_cf -d $topDomain -d *.$topDomain -k ec-256
"/root/.acme.sh"/acme.sh --installcert -d $topDomain --ecc \
               --key-file       /var/www/ssl/de_GWD.key  \
               --fullchain-file /var/www/ssl/de_GWD.cer \
               --reloadcmd     "systemctl force-reload nginx"

chmod 644 /var/www/ssl/*.key
}



makeSSL_W(){
crontab -l 2>/dev/null >/tmp/now.cron
sed -i '/acme.sh/d' /tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron
rm -rf "/root/.acme.sh"

rm -rf /etc/nginx/conf.d/80.conf
rm -rf /etc/nginx/conf.d/default.conf
cat << EOF >/etc/nginx/conf.d/default.conf
#SERVER_BASE_START
server {
    listen      80;
    server_name $domain;
    root        /var/www/html;
    index       index.php index.html index.htm;
#SERVER_BASE_END
}
EOF

if [[ $(systemctl is-active 'nginx') != "active" ]]; then
  systemctl restart nginx
  if [[ $? -ne 0 ]]; then
  sed -i '/Nice=/d' /etc/systemd/system/nginx.service
  ln -sf /etc/systemd/system/nginx.service /lib/systemd/system/nginx.service >/dev/null 2>&1
  systemctl daemon-reload >/dev/null
  systemctl restart nginx
  fi
else
systemctl force-reload nginx
fi

rm -rf /var/www/ssl/*.cer
rm -rf /var/www/ssl/*.key
[[ -f "/var/www/ssl/bundle.pem" ]] && ls /var/www/ssl/*.pem | xargs -n 1 | grep -v "dhparam.pem" | while read line
do
rm -rf $line
done

[[ ! -f "/var/www/ssl/dhparam.pem" ]] && openssl dhparam -out /var/www/ssl/dhparam.pem 2048

curl https://get.acme.sh | sh
"/root/.acme.sh"/acme.sh --upgrade  --auto-upgrade
"/root/.acme.sh"/acme.sh --set-default-ca  --server letsencrypt
"/root/.acme.sh"/acme.sh --issue -d $domain -w /var/www/html -k ec-256
"/root/.acme.sh"/acme.sh --installcert -d $domain --ecc \
               --key-file       /var/www/ssl/de_GWD.key  \
               --fullchain-file /var/www/ssl/de_GWD.cer \
               --reloadcmd     "systemctl force-reload nginx"

chmod 644 /var/www/ssl/*.key
}


ocspStapling(){
cat << "EOF" >/var/www/ssl/update_ocsp_cache
#!/bin/bash
if [[ -n $(openssl x509 -enddate -noout -in /var/www/ssl/de_GWD.cer -checkend 86400 | grep ' not ') ]]; then
[[ ! -f "/var/www/ssl/intermediate.pem" ]] && wget --show-progress -t 5 -T 10 -cqO /var/www/ssl/intermediate.pem https://letsencrypt.org/certs/lets-encrypt-r3-cross-signed.pem
[[ ! -f "/var/www/ssl/root.pem" ]] && wget --show-progress -t 5 -T 10 -cqO /var/www/ssl/root.pem https://letsencrypt.org/certs/isrgrootx1.pem

[[ ! -f "/var/www/ssl/bundle.pem" ]] && cat /var/www/ssl/intermediate.pem >/var/www/ssl/bundle.pem && cat /var/www/ssl/root.pem >>/var/www/ssl/bundle.pem

openssl ocsp -no_nonce \
    -issuer  /var/www/ssl/intermediate.pem \
    -cert    /var/www/ssl/*.cer \
    -CAfile  /var/www/ssl/bundle.pem \
    -VAfile  /var/www/ssl/bundle.pem \
    -url     http://r3.o.lencr.org \
    -respout /var/www/ssl/ocsp.resp

chmod 644 /var/www/ssl/*.key
systemctl force-reload nginx >/dev/null
fi
EOF

chmod +x /var/www/ssl/update_ocsp_cache
/var/www/ssl/update_ocsp_cache
}



nginxWebConf(){
if [[ $port = "443" ]]; then
cat << EOF >/etc/nginx/conf.d/80.conf
server {
  listen 80;
  server_name $domain;
  return 301 https://\$server_name\$request_uri;
}
EOF
else
rm -rf /etc/nginx/conf.d/80.conf
fi

touch /etc/nginx/conf.d/default.conf
sed -i '/SERVER_BASE_START/,/SERVER_BASE_END/d' /etc/nginx/conf.d/default.conf
sed -i '/DOH_START/,/DOH_END/d' /etc/nginx/conf.d/default.conf
sed -i '/V2_START/,/V2_END/d' /etc/nginx/conf.d/default.conf
sed -i '$s/}$//' /etc/nginx/conf.d/default.conf

until [[ $(head -1 /etc/nginx/conf.d/default.conf | cat -e) != "$" ]]
do
   sed -i '1d' /etc/nginx/conf.d/default.conf
done

until [[ $(tail -1 /etc/nginx/conf.d/default.conf | cat -e) != "$" ]]
do
   sed -i '$d' /etc/nginx/conf.d/default.conf
done

cat << EOF >/etc/nginx/conf.d/default.conf
#SERVER_BASE_START
server {
  listen $port ssl http2 fastopen=128 reuseport;
  server_name $domain;
  root /var/www/html;
  index index.php index.html index.htm;

  ssl_certificate /var/www/ssl/de_GWD.cer;
  ssl_certificate_key /var/www/ssl/de_GWD.key;
  ssl_dhparam /var/www/ssl/dhparam.pem;
  ssl_protocols TLSv1.2 TLSv1.3;
  ssl_prefer_server_ciphers on;
  ssl_ciphers  '[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305|ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305] ECDHE-ECDSA-AES256-GCM-SHA384 ECDHE-RSA-AES256-GCM-SHA384 ECDHE-ECDSA-AES128-SHA256 ECDHE-RSA-AES128-SHA256';
  ssl_session_timeout 10m;
  ssl_session_cache builtin:1000 shared:SSL:10m;
  ssl_buffer_size 4k;

  ssl_early_data on;
  proxy_set_header Early-Data \$ssl_early_data;

  ssl_stapling on;
  ssl_stapling_verify on;
  ssl_stapling_file /var/www/ssl/ocsp.resp;
  
  add_header Referrer-Policy                    "no-referrer"       always;
  add_header X-Content-Type-Options             "nosniff"           always;
  add_header X-Download-Options                 "noopen"            always;
  add_header X-Frame-Options                    "SAMEORIGIN"        always;
  add_header X-Permitted-Cross-Domain-Policies  "none"              always;
  add_header X-Robots-Tag                       "none"              always;
  add_header X-XSS-Protection                   "1; mode=block"     always;
  add_header Strict-Transport-Security          "max-age=63072000"  always;

location ~ /\.(?!well-known).* {
    deny all;
    access_log off;
    log_not_found off;
}
#SERVER_BASE_END

#DOH_START
location /dq {
  proxy_pass                  http://127.0.0.1:8053/dq;
  proxy_set_header            Host \$host;
  proxy_set_header            X-Real-IP \$remote_addr;
}
#DOH_END

#V2_START
location $path {
  if (\$http_upgrade != "websocket") { return 404; }
  proxy_pass                  http://unix:/dev/shm/de_GWD.socket;
  proxy_http_version          1.1;
  proxy_set_header            Host \$http_host;
  proxy_set_header            Upgrade \$http_upgrade;
  proxy_set_header            Connection "upgrade";
  proxy_set_header            X-Real-IP \$remote_addr;
  proxy_set_header            X-Forwarded-For \$proxy_add_x_forwarded_for;
  keepalive_requests          100000;
  keepalive_timeout           500s 500s;
  proxy_connect_timeout       500s;
  proxy_read_timeout          500s;
  proxy_send_timeout          500s;
  proxy_redirect              off;
  proxy_buffering             off;
  proxy_buffer_size           8k;
  add_header                  X-Cache \$upstream_cache_status;
  add_header                  Cache-Control no-cache;
}
#V2_END

$(cat /etc/nginx/conf.d/default.conf 2>/dev/null)
}
EOF
}



xrayInbound(){
cat << EOF >/opt/de_GWD/vtrui/config.json
{
  "dns":{
    "disableCache":true,
    "servers":["localhost"]
  },
  "inbounds":[
    {
      "listen":"/dev/shm/de_GWD.socket",
      "protocol":"vless",
      "settings":{
        "decryption":"none",
        "clients":[]
      },
      "streamSettings":{
        "network":"ws",
        "security":"none",
        "wsSettings":{
          "path":"$path"
        }
      }
    }
  ]
}
EOF

for uuid in $uuids; do
uuidStr='{"id": "'$uuid'", "level": 1}'
jq --argjson uuidStr "$uuidStr" '.inbounds[0].settings.clients+=[$uuidStr]' /opt/de_GWD/vtrui/config.json | sponge /opt/de_GWD/vtrui/config.json
done
}

xrayInboundForward(){
chmod 644 /var/www/ssl/*.key
IBup=`cat << EOF
    {
      "tag": "forward",
      "port": $xtlsPort,
      "protocol": "vless",
      "settings":{
        "decryption": "none",
        "clients":[]
      },
      "streamSettings": {
        "network": "tcp",
        "security": "xtls",
        "xtlsSettings": {
          "rejectUnknownSni": true,
          "alpn":["h2","http/1.1"],
          "certificates": [
            {
              "certificateFile": "/var/www/ssl/de_GWD.cer",
              "keyFile": "/var/www/ssl/de_GWD.key"
            }
          ]
        }
      }
    }
EOF
`

jq 'del(.inbounds[] | select(.tag == "forward"))' /opt/de_GWD/vtrui/config.json |\
jq --argjson IBup "$IBup" '.inbounds+=[$IBup]' | sponge /opt/de_GWD/vtrui/config.json

IFNO=$(jq -r '.inbounds | to_entries[] | select(.value.tag == "forward") | .key' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
for uuid in $uuids; do
xuuidStr='{"id": "'$uuid'", "flow": "xtls-rprx-direct", "level": 1}'
jq --argjson IFNO "$IFNO" --argjson xuuidStr "$xuuidStr" '.inbounds[$IFNO].settings.clients+=[$xuuidStr]' /opt/de_GWD/vtrui/config.json | sponge /opt/de_GWD/vtrui/config.json
done
}

xrayOutboundForward(){
OBup=`cat << EOF
    {
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "$upDomain",
            "port": $upPort,
            "users": [
              {
                "id": "$upUUID",
                "encryption": "none",
                "flow": "xtls-rprx-direct",
                "level": 1
              }
            ]
          }
        ]
      },
      "streamSettings": {
        "network": "tcp",
        "security": "xtls",
        "xtlsSettings": {
          "serverName": "$upDomain",
          "allowInsecure": false
        },
        "sockopt":{
          "domainStrategy":"UseIP"
        }
      }
    }
EOF
`

OBdir=`cat << EOF
    {
      "tag":"direct",
      "protocol":"freedom"
    }
EOF
`

OBblo=`cat << EOF
    {
      "tag":"blocked",
      "protocol":"blackhole",
      "settings":{"response":{"type":"http"}}
    }
EOF
`

jq '.outbounds=[]' /opt/de_GWD/vtrui/config.json |\
jq --argjson OBup "$OBup" '.outbounds+=[$OBup]' |\
jq --argjson OBdir "$OBdir" '.outbounds+=[$OBdir]' |\
jq --argjson OBblo "$OBblo" '.outbounds+=[$OBblo]' | sponge /opt/de_GWD/vtrui/config.json

[[ $virt_type == "container" ]] && jq --arg flow "xtls-rprx-direct" '.outbounds[0].settings.vnext[0].users[0].flow=$flow' /opt/de_GWD/vtrui/config.json | sponge /opt/de_GWD/vtrui/config.json
}

xrayOutboundDirect(){
OBdir=`cat << EOF
    {
      "tag":"direct",
      "protocol":"freedom"
    }
EOF
`

OBblo=`cat << EOF
    {
      "tag":"blocked",
      "protocol":"blackhole",
      "settings":{"response":{"type":"http"}}
    }
EOF
`

jq '.outbounds=[]' /opt/de_GWD/vtrui/config.json |\
jq --argjson OBdir "$OBdir" '.outbounds+=[$OBdir]' |\
jq --argjson OBblo "$OBblo" '.outbounds+=[$OBblo]' | sponge /opt/de_GWD/vtrui/config.json
}



clearKernel(){
mkdir -p /opt/de_GWD
cat << "EOF" >/opt/de_GWD/clearKernel
#!/bin/bash
PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'

sed -i "/net.core.default_qdisc/d" /etc/sysctl.conf
sed -i '/net.ipv4.tcp_congestion_control/d' /etc/sysctl.conf

if [[ $(uname -r) =~ "bbrplus" ]]; then
  echo "net.core.default_qdisc = fq_codel" >>/etc/sysctl.conf
  echo "net.ipv4.tcp_congestion_control = bbrplus" >>/etc/sysctl.conf
else
  echo "net.core.default_qdisc = fq_codel" >>/etc/sysctl.conf
  echo "net.ipv4.tcp_congestion_control = bbr" >>/etc/sysctl.conf
fi

sysctl -p >/dev/null
systemctl restart systemd-sysctl

dpkg --list | grep linux-image | awk '{print $2}' | grep -Fv $(uname -r) | while read line
do
apt -y purge $line
done

dpkg --list | grep linux-headers | awk '{print $2}' | grep -Fv $(uname -r) | while read line
do
apt -y purge $line
done
EOF
chmod +x /opt/de_GWD/clearKernel
}



postInstall(){
if [[ $(ls /var/www/html/* 2>/dev/null | wc -l) -lt 5 ]]; then
if [[ $(unzip -tq /opt/de_GWD/.repo/sample.zip 2>/dev/null) =~ "No errors" ]]; then
rm -rf /tmp/sample 
unzip /opt/de_GWD/.repo/sample.zip -d /tmp >/dev/null 2>&1 
cp -rf /tmp/sample/* /var/www/html/
rm -rf /tmp/sample
else
rm -rf /opt/de_GWD/.repo/sample.zip
red "Download Failed" && exit
fi
fi

if [[ $(du -sk /var/www/html/spt 2>/dev/null | awk '{print$1}') -lt 102400 ]]; then
  dd if=/dev/zero of=/var/www/html/spt bs=1k count=100k status=progress
fi



cat << "EOF" >/opt/de_GWD/Q2H
#!/bin/bash
virt=$(systemd-detect-virt)
virtCON="openvz lxc lxc-libvirt systemd-nspawn docker podman rkt wsl proot pouch"

[[ $virt_type != "container" ]] && /opt/de_GWD/tcpTime

rm -rf ~/server*
rm -rf ~/wget-log
rm -rf /var/log/*1
rm -rf /var/log/*2
rm -rf /var/log/*gz
EOF
chmod +x /opt/de_GWD/Q2H
/opt/de_GWD/Q2H


cat << "EOF" >/opt/de_GWD/Qday
#!/bin/bash
if [[ -n $(openssl x509 -enddate -noout -in /var/www/ssl/de_GWD.cer -checkend 259200 | grep "Certificate will expire") ]] && [[ -d "/root/.acme.sh" ]]; then
"/root/.acme.sh"/acme.sh --set-default-ca  --server letsencrypt
"/root/.acme.sh"/acme.sh --cron --force --home "/root/.acme.sh"

sslFolder=$(ls "/root/.acme.sh" | grep '_ecc')
cp -f "/root/.acme.sh"/$sslFolder/fullchain.cer /var/www/ssl/de_GWD.cer
cp -f "/root/.acme.sh"/$sslFolder/*.key /var/www/ssl/de_GWD.key

chmod 644 /var/www/ssl/*.key
systemctl restart vtrui
fi

/var/www/ssl/update_ocsp_cache
EOF
chmod +x /opt/de_GWD/Qday


cat << EOF > /etc/rc.local
#!/bin/bash
if [[ \$(systemd-detect-virt) == "none" ]]; then
find /sys/class/net ! -type d | xargs --max-args=1 realpath | awk -F\/ '/pci/{print \$NF}' | while read line
do
[[ \$(ethtool -g \$line | awk '/Pre-set maximums/,/Current hardware settings/' | grep 'RX:' | grep -o '[0-9]\+') -ge 2048 ]] && ethtool -G \$line rx 2048 >/dev/null 2>&1
[[ \$(ethtool -g \$line | awk '/Pre-set maximums/,/Current hardware settings/' | grep 'TX:' | grep -o '[0-9]\+') -ge 2048 ]] && ethtool -G \$line tx 2048 >/dev/null 2>&1
ethtool -s \$line duplex full >/dev/null 2>&1
ethtool -K \$line tso off  gso off >/dev/null 2>&1
done
else
find /sys/class/net ! -type d | xargs --max-args=1 realpath | awk -F\/ '/pci/{print \$NF}' | while read line
do
ethtool -s \$line duplex full >/dev/null 2>&1
ethtool -K \$line rx off  tx off  sg off  tso off  gso off  lro off  gro off  rx-gro-hw off >/dev/null 2>&1
done
fi

ip route change \$(ip route show | grep '^default' | head -1) initcwnd 32 initrwnd 32 >/dev/null 2>&1
EOF
chmod +x /etc/rc.local
/etc/rc.local


clearKernel


crontab -l 2>/dev/null >/tmp/now.cron
sed -i '/\/opt\/de_GWD\/Qprobe/d' /tmp/now.cron
sed -i '/\/opt\/de_GWD\/Q2H/d' /tmp/now.cron
sed -i '/\/opt\/de_GWD\/Qday/d' /tmp/now.cron
sed -i '/\/opt\/de_GWD\/Q4amSun/d' /tmp/now.cron
sed -i '/\/opt\/de_GWD\/clearKernel/d' /tmp/now.cron
cat << EOF >>/tmp/now.cron
0 */2 * * * /opt/de_GWD/Q2H
0 0 * * * /opt/de_GWD/Qday
@reboot /opt/de_GWD/clearKernel
EOF
crontab /tmp/now.cron
rm -rf /tmp/now.cron
service cron restart

echo -n "$statuSuccess" && white "Post Install"

cat << "EOF" >/tmp/comRestart
#!/bin/bash
virt=$(systemd-detect-virt)
[[ -n $(echo "openvz lxc lxc-libvirt systemd-nspawn docker podman rkt wsl proot pouch" | grep $virt) ]] && virt_type="container"

if [[ $virt_type == "container" ]]; then
sed -i '/de_GWD.socket/c\proxy_pass http://127.0.0.1:9896;' /etc/nginx/conf.d/default.conf
jq 'del(.inbounds[0].listen)' /opt/de_GWD/vtrui/config.json |\
jq '.inbounds[0].port=9896' | sponge /opt/de_GWD/vtrui/config.json
fi

systemctl restart doh-server
if [[ $? -ne 0 ]]; then
sed -i '/Nice=/d' /etc/systemd/system/doh-server.service
ln -sf /etc/systemd/system/doh-server.service /lib/systemd/system/doh-server.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null
systemctl restart doh-server
fi
systemctl enable doh-server >/dev/null 2>&1

systemctl restart vtrui
if [[ $? -ne 0 ]]; then
sed -i '/Nice=/d' /etc/systemd/system/vtrui.service
ln -sf /etc/systemd/system/vtrui.service /lib/systemd/system/vtrui.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null
systemctl restart vtrui
fi
systemctl enable vtrui >/dev/null 2>&1

systemctl restart nginx
if [[ $? -ne 0 ]]; then
sed -i '/Nice=/d' /etc/systemd/system/nginx.service
ln -sf /etc/systemd/system/nginx.service /lib/systemd/system/nginx.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null
systemctl restart nginx
fi
systemctl enable nginx >/dev/null 2>&1

rm -rf /tmp/comRestart
EOF
chmod +x /tmp/comRestart
screen -dmS comRestart /tmp/comRestart
sleep 3
}


checkKernel(){
if [[ $(dpkg --list | grep linux-image | wc -l) != "1" ]]; then
red "Kernel updated & reboot"
sleep 2
sudo reboot
exit
fi
}






installBBRplus(){
if [[ $virt_type != "container" ]]; then
mkdir -p /boot/grub
[[ -z $(which 'update-grub') ]] && [[ -d "/sys/firmware/efi" ]] && apt update && apt install -y grub-efi && grub-mkconfig -o /boot/grub/grub.cfg
[[ -z $(which 'update-grub') ]] && [[ ! -d "/sys/firmware/efi" ]] && apt update && apt install -y grub2-common && grub-mkconfig -o /boot/grub/grub.cfg

wget --show-progress -t 5 -T 10 -cqO /tmp/linux-image.deb https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/linux-image-bbrplus_$architecture.deb
[[ -f "/tmp/linux-image.deb" ]] && linux_image_sha256sumL=$(sha256sum /tmp/linux-image.deb 2>/dev/null | awk '{print$1}')
linux_image_sha256sum=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/linux-image-bbrplus_"$architecture".deb.sha256sum)
[[ $linux_image_sha256sum != $linux_image_sha256sumL ]] && red "Download Failed" && exit

wget --show-progress -t 5 -T 10 -cqO /tmp/linux-headers.deb https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/linux-headers-bbrplus_$architecture.deb
[[ -f "/tmp/linux-headers.deb" ]] && linux_headers_sha256sumL=$(sha256sum /tmp/linux-headers.deb 2>/dev/null | awk '{print$1}')
linux_headers_sha256sum=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/$branch/resource/linux-headers-bbrplus_"$architecture".deb.sha256sum)
[[ $linux_headers_sha256sum != $linux_headers_sha256sumL ]] && red "Download Failed" && exit

dpkg -i /tmp/linux-image.deb
dpkg -i /tmp/linux-headers.deb

if [[ -n $(dpkg --list | grep 'linux-image' | grep 'bbrplus') ]]; then
dpkg --list | awk '{print $2}' | grep 'liquorix' | grep 'linux-' | while read line
do
apt -y purge $line
done
  apt-key del 2FB2CD80 >/dev/null 2>&1
  apt-key del 33F8024D >/dev/null 2>&1
  rm -rf /etc/apt/sources.list.d/liquorix.list
  rm -rf /etc/apt/trusted.gpg.d/liquorix-keyring.gpg
  
dpkg --list | awk '{print $2}' | grep 'xanmod' | grep 'linux-' | while read line
do
apt -y purge $line
done
  apt-key del E734E623 >/dev/null 2>&1
  rm -rf /etc/apt/sources.list.d/xanmod-kernel.list
  rm -rf /usr/share/keyrings/xanmod-kernel-archive-keyring.gpg

dpkg --list | awk '{print $2}' | grep 'linux-image' | sed "/$BBRPLUS_Ver-bbrplus/d" | while read line
do
apt -y purge $line
done

dpkg --list | awk '{print $2}' | grep 'linux-headers' | sed "/$BBRPLUS_Ver-bbrplus/d" | while read line
do
apt -y purge $line
done

update-initramfs -u -k all
update-grub

if [[ ! -f "/opt/de_GWD/clearKernel" ]]; then
clearKernel

crontab -l 2>/dev/null >/tmp/now.cron
sed -i '/\/opt\/de_GWD\/clearKernel/d' /tmp/now.cron
echo '@reboot /opt/de_GWD/clearKernel' >>/tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron
fi

blue "------------------------------"
blue  "Install BBRplus kernel [done]"
blue "------------------------------"
reboot
exit
else
  echo -n "$statusFailed" && red "bbrplus kernel install failed"
  exit
fi
elif [[ $virt_type == "container" ]]; then
  bash <(wget --no-check-certificate -qO- https://github.com/mzz2017/lkl-haproxy/raw/master/lkl-haproxy.sh)
fi
}



installLiquorix(){
if [[ $architecture != "amd64" ]]; then
  red "only work on x86_64"
elif [[ $architecture == "amd64" ]]; then
mkdir -p /boot/grub
[[ -z $(which 'update-grub') ]] && [[ -d "/sys/firmware/efi" ]] && apt update && apt install -y grub-efi && grub-mkconfig -o /boot/grub/grub.cfg
[[ -z $(which 'update-grub') ]] && [[ ! -d "/sys/firmware/efi" ]] && apt update && apt install -y grub2-common && grub-mkconfig -o /boot/grub/grub.cfg

mkdir -p /etc/apt/{sources.list.d,trusted.gpg.d}
curl -o /etc/apt/trusted.gpg.d/liquorix-keyring.gpg https://liquorix.net/liquorix-keyring.gpg
echo "deb http://liquorix.net/debian $(cat /etc/os-release | grep VERSION= | cut -d'(' -f2 | cut -d')' -f1) main" >/etc/apt/sources.list.d/liquorix.list

apt update && apt install -y linux-image-liquorix-amd64 linux-headers-liquorix-amd64

if [[ -n $(dpkg --list | grep linux-image | grep liquorix) ]]; then
  apt-key del E734E623 >/dev/null 2>&1
  rm -rf /etc/apt/sources.list.d/xanmod-kernel.list
  rm -rf /usr/share/keyrings/xanmod-kernel-archive-keyring.gpg
dpkg --list | awk '{print $2}' | grep 'linux-image' | sed '/liquorix/d' | while read line
do
apt -y purge $line
done

dpkg --list | awk '{print $2}' | grep 'linux-headers' | sed '/liquorix/d' | while read line
do
apt -y purge $line
done

update-initramfs -u -k all
update-grub

if [[ ! -f "/opt/de_GWD/clearKernel" ]]; then
clearKernel

crontab -l 2>/dev/null >/tmp/now.cron
sed -i '/\/opt\/de_GWD\/clearKernel/d' /tmp/now.cron
echo '@reboot /opt/de_GWD/clearKernel' >>/tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron
fi

blue "------------------------------"
blue "Install Liquorix kernel [done]"
blue "------------------------------"
reboot
exit
else
  echo -n "$statusFailed" && red "Liquorix kernel install failed"
  echo
  echo -n "$statusWarning" && yellow "Installation Fallback"

  dpkg --list | awk '{print $2}' | grep liquorix | while read line
  do
  apt -y purge $line
  done

  apt-key del 2FB2CD80 >/dev/null 2>&1
  apt-key del 33F8024D >/dev/null 2>&1
  rm -rf /etc/apt/sources.list.d/liquorix.list
  rm -rf /etc/apt/trusted.gpg.d/liquorix-keyring.gpg
  echo -n "$statusWarning" && yellow "Exit"
  exit
fi
fi
}



installXanMod(){
if [[ $architecture != "amd64" ]]; then
  red "only work on x86_64"
elif [[ $architecture == "amd64" ]]; then
mkdir -p /boot/grub
[[ -z $(which 'update-grub') ]] && [[ -d "/sys/firmware/efi" ]] && apt update && apt install -y grub-efi && grub-mkconfig -o /boot/grub/grub.cfg
[[ -z $(which 'update-grub') ]] && [[ ! -d "/sys/firmware/efi" ]] && apt update && apt install -y grub2-common && grub-mkconfig -o /boot/grub/grub.cfg

mkdir -p /etc/apt/{sources.list.d,trusted.gpg.d}
curl -fsSLo- https://dl.xanmod.org/gpg.key | gpg --dearmor >/usr/share/keyrings/xanmod-kernel-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/xanmod-kernel-archive-keyring.gpg] http://deb.xanmod.org releases main" >/etc/apt/sources.list.d/xanmod-kernel.list

apt update && apt install linux-xanmod-lts -y

if [[ -n $(dpkg --list | grep linux-image | grep xanmod) ]]; then
  apt-key del 2FB2CD80 >/dev/null 2>&1
  apt-key del 33F8024D >/dev/null 2>&1
  rm -rf /etc/apt/sources.list.d/liquorix.list
  rm -rf /etc/apt/trusted.gpg.d/liquorix-keyring.gpg
dpkg --list | awk '{print $2}' | grep 'linux-image' | sed '/xanmod/d' | while read line
do
apt -y purge $line
done

dpkg --list | awk '{print $2}' | grep 'linux-headers' | sed '/xanmod/d' | while read line
do
apt -y purge $line
done

update-initramfs -u -k all
update-grub

if [[ ! -f "/opt/de_GWD/clearKernel" ]]; then
clearKernel

crontab -l 2>/dev/null >/tmp/now.cron
sed -i '/\/opt\/de_GWD\/clearKernel/d' /tmp/now.cron
echo '@reboot /opt/de_GWD/clearKernel' >>/tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron
fi

blue "----------------------------"
blue "Install XanMod kernel [done]"
blue "----------------------------"
reboot
exit
else
  echo -n "$statusFailed" && red "XanMod kernel install failed"
  echo
  echo -n "$statusWarning" && yellow "Installation Fallback"

  dpkg --list | awk '{print $2}' | grep xanmod | while read line
  do
  apt -y purge $line
  done

  apt-key del E734E623 >/dev/null 2>&1
  rm -rf /etc/apt/sources.list.d/xanmod-kernel.list
  rm -rf /usr/share/keyrings/xanmod-kernel-archive-keyring.gpg
  echo -n "$statusWarning" && yellow "Exit"
  exit
fi
fi
}



install3rdKernel(){
    green "========================================"
    green "[1]: Install BBRplus kernel and reboot"
    green "[2]: Install Liquorix kernel and reboot"
    green "[3]: Install XanMod kernel and reboot"
    green "========================================"
    read -s -n 1 kernelSwitch
echo
case $kernelSwitch in
  "1")
    installBBRplus
    ;;
  "2")
    installLiquorix
    ;;
  "3")
    installXanMod
    ;;
esac
}



restoreKernel(){
    green "======================="
    green "Restore Default Kernel"
    green "======================="
    green "Press [Enter] to continue:"
    read -s -n 1 restoreKconfirm

if [[ $restoreKconfirm = "" ]]; then

if [[ $architecture != "amd64" ]]; then
  red "only work on x86_64"
elif [[ $architecture == "amd64" ]]; then
mkdir -p /boot/grub
[[ -z $(which 'update-grub') ]] && [[ -d "/sys/firmware/efi" ]] && apt update && apt install -y grub-efi && grub-mkconfig -o /boot/grub/grub.cfg
[[ -z $(which 'update-grub') ]] && [[ ! -d "/sys/firmware/efi" ]] && apt update && apt install -y grub2-common && grub-mkconfig -o /boot/grub/grub.cfg

apt update && apt install -y linux-image-amd64 linux-headers-amd64

if [[ -n $(dpkg --list | grep 'linux-image-amd64') ]]; then
dpkg --list | awk '{print $2}' | grep 'liquorix' | grep 'linux-' | while read line
do
apt -y purge $line
done
  apt-key del 2FB2CD80 >/dev/null 2>&1
  apt-key del 33F8024D >/dev/null 2>&1
  rm -rf /etc/apt/sources.list.d/liquorix.list
  rm -rf /etc/apt/trusted.gpg.d/liquorix-keyring.gpg
  
dpkg --list | awk '{print $2}' | grep 'xanmod' | grep 'linux-' | while read line
do
apt -y purge $line
done
  apt-key del E734E623 >/dev/null 2>&1
  rm -rf /etc/apt/sources.list.d/xanmod-kernel.list
  rm -rf /usr/share/keyrings/xanmod-kernel-archive-keyring.gpg

dpkg --list | awk '{print $2}' | grep 'bbrplus' | grep 'linux-' | while read line
do
apt -y purge $line
done

update-initramfs -u -k all
update-grub

if [[ ! -f "/opt/de_GWD/clearKernel" ]]; then
clearKernel

crontab -l 2>/dev/null >/tmp/now.cron
sed -i '/\/opt\/de_GWD\/clearKernel/d' /tmp/now.cron
echo '@reboot /opt/de_GWD/clearKernel' >>/tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron
fi

blue "-----------------------------"
blue "Restore Default Kernel [done]"
blue "-----------------------------"
reboot
exit
else
  echo -n "$statusFailed" && red "Default kernel install failed"
  echo
  echo -n "$statusWarning" && yellow "Installation Fallback"
  echo -n "$statusWarning" && yellow "Exit"
  exit
fi
fi
fi
}



changeDomain(){
    green "=================="
    green " Input new domain"
    green "=================="
    read vpsdomainP

domain=$(echo $vpsdomainP | cut -d: -f1)
topDomain=$(echo $domain | rev | awk -F. '{print $1"."$2}' | rev)
port=$(echo $vpsdomainP | cut -d: -f2| grep '^[[:digit:]]*$')
[[ -z $port ]] && port="443"

path=$(jq -r '.inbounds[0].streamSettings.wsSettings.path' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')

if [[ $port == "443" ]]; then
makeSSL_W

ocspStapling
else
    green "==============================="
    green " Cloudflare API KEY"
    green "==============================="
    read CFapikey

    green "==============================="
    green " Cloudflare Email"
    green "==============================="
    read CFemail

makeSSL_D

ocspStapling
fi

nginxWebConf

systemctl force-reload nginx

blue "-----------------------------------------------"
blue "Change domain and issue new certificates [done]"
blue "-----------------------------------------------"
}



changeXrayVerify(){
    green "=========="
    green " New UUID"
    green "=========="
    read nuuid

    green "=========="
    green " New Path"
    green "=========="
    read npath

domain=$(awk '/server_name/ {print$2;exit}' /etc/nginx/conf.d/default.conf | sed 's/.$//')
topDomain=$(echo $domain | rev | awk -F. '{print $1"."$2}' | rev)
port=$(awk '/ssl http2 fastopen=128 reuseport/ {print$2}' /etc/nginx/conf.d/default.conf | grep '^[[:digit:]]*$')

path=$npath
uuids=$nuuid

upDomain=$(jq -r '.outbounds[0].settings.vnext[0].address' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
upPort=$(jq -r '.outbounds[0].settings.vnext[0].port' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
upUUID=$(jq -r '.outbounds[0].settings.vnext[0].users[0].id' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
xtlsPort=$(jq -r '.inbounds[] | select(.tag == "forward") | .port' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')

nginxWebConf

systemctl force-reload nginx

xrayInbound

if [[ -n $xtlsPort ]]; then
  xrayInboundForward
fi

if [[ -n $upDomain ]]; then
  xrayOutboundForward
else
  xrayOutboundDirect
fi

systemctl restart vtrui >/dev/null 2>&1

blue "-----------------------------"
blue  "Change Xray UUID&path [done]"
blue "-----------------------------"
}



changeWGCF(){
    green "================================================"
    green "[1]: Enable Cloudflare wireguard upstream (WARP)"
    green "[2]: Delete Cloudflare wireguard upstream (WARP)"
    green "================================================"
    read -s -n 1 WGCFswitch
if [[ $WGCFswitch = "1" ]]; then
uname -r 2>&1 | grep -o '[0-9.]*' | head -n 1 >/tmp/kernelVer
echo "5.6" >>/tmp/kernelVer

if [[ $(cat /tmp/kernelVer |sort -rV | head -n 1) = "5.6" ]]; then
    echo -n "$statusWarning" && red "Update kernel first!"
else
ethernetnum=$(ip --oneline link show up | grep -v "lo" | awk '{print$2;exit}' | cut -d':' -f1 | cut -d'@' -f1)
localaddrIPv4=$(ip -4 a | grep inet | grep -v 127.0.0 | awk '{print $2}' | cut -d'/' -f1 | head -n 1)
if [[ -n $localaddrIPv4 ]]; then

unset aptPKG
[[ -z $(dpkg -l | awk '{print$2}' | grep '^wireguard-tools$') ]] && aptPKG+=(wireguard-tools)
[[ -n $aptPKG ]] && apt update && apt install $(echo ${aptPKG[@]})

wgcfRelease=$(curl -kLs "https://api.github.com/repos/ViRb3/wgcf/releases/latest" | jq -r '.tag_name' | grep -v '^null$')
wget --show-progress -t 5 -T 10 -cqO /usr/local/bin/wgcf https://github.com/ViRb3/wgcf/releases/download/$wgcfRelease/wgcf_$(echo $wgcfRelease | tr -d v)_linux_$architecture
[[ $? -ne 0 ]] && red "Download Failed" && exit
chmod +x /usr/local/bin/wgcf

echo | wgcf register
wgcf generate

PrivateKey=$(cat wgcf-profile.conf | awk '/PrivateKey/{print$3}')
PublicKey=$(cat wgcf-profile.conf | awk '/PublicKey/{print$3}')

cat << EOF >/etc/wireguard/wgcf.conf
[Interface]
PrivateKey = $PrivateKey
Address = 172.16.0.2/32
PostUp = ip rule add from $localaddrIPv4 lookup main
PostDown = ip rule del from $localaddrIPv4 lookup main
DNS = 127.0.0.1
MTU = 1420
[Peer]
PublicKey = $PublicKey
AllowedIPs = 0.0.0.0/0
AllowedIPs = ::/0
EndPoint = 162.159.193.10:2408
EOF

rm -rf wgcf-account.toml >/dev/null 2>&1
rm -rf wgcf-profile.conf >/dev/null 2>&1

rm -rf /lib/systemd/system/wg-quick@.service
cat << "EOF" >/etc/systemd/system/wg-quick@.service
[Unit]
Description=WireGuard via wg-quick(8) for %I
After=network-online.target nss-lookup.target
Wants=network-online.target nss-lookup.target
PartOf=wg-quick.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/wg-quick up %i
ExecStop=/usr/bin/wg-quick down %i
ExecReload=/bin/bash -c 'exec /usr/bin/wg syncconf %i <(exec /usr/bin/wg-quick strip %i)'
Environment=WG_ENDPOINT_RESOLUTION_RETRIES=infinity

[Install]
WantedBy=multi-user.target
EOF
ls -sf /etc/systemd/system/wg-quick@.service /lib/systemd/system/wg-quick@.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null

cat << "EOF" >/tmp/WGCFstart
#!/bin/bash
systemctl restart wg-quick@wgcf
systemctl enable wg-quick@wgcf

rm -rf /run/resolvconf/interface
resolvconf -u

rm -rf /tmp/WGCFstart
EOF
chmod +x /tmp/WGCFstart

screen -dmS WGCFstart /tmp/WGCFstart
sleep 3

wanIP=$(curl -4Ls whatismyip.akamai.com | grep -Po '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
[[ -z $wanIP ]] && wanIP=$(curl -4Ls ifconfig.me | grep -Po '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')

blue "-------------------------------------------------------------"
[[ $localaddrIPv4 != $wanIP ]] && echo -n "$statuSuccess" && white "Cloudflare wireguard upstream (WARP) [Enabled]"
[[ $localaddrIPv4 == $wanIP ]] && echo -n "$statusFailed" && red "Cloudflare wireguard upstream (WARP) [failed]"
blue "-------------------------------------------------------------"
else
echo -n "$statusFailed" && red "This vps has no IPv4 address"
fi
fi
elif [[ $WGCFswitch = "2" ]]; then
cat << "EOF" >/tmp/WGCFstop
#!/bin/bash
systemctl stop wg-quick@wgcf
systemctl disable wg-quick@wgcf
rm -rf /run/resolvconf/interface
resolvconf -u
rm -rf /etc/wireguard/wgcf.conf
rm -rf /usr/local/bin/wgcf

rm -rf /tmp/WGCFstop
EOF
chmod +x /tmp/WGCFstop

screen -dmS WGCFstop /tmp/WGCFstop
blue "------------------------------------------------"
blue  "Cloudflare wireguard upstream (WARP) [Disabled]"
blue "------------------------------------------------"
fi
}



changeXTLSF(){
    green "==========================="
    green "[1]: Connect to XTLS server"
    green "[2]: Set XTLS Server"
    green "[3]: Delete XTLS forward"
    green "==========================="
    read -s -n 1 xtlsSet

if [[ $xtlsSet = "1" ]]; then
    green "==========================="
    green "XTLS upstream Domain & Port"
    green "==========================="
    read upDomainP

    green "==========================="
    green "XTLS upstream UUID"
    green "==========================="
    read upUUID

upDomain=$(echo $upDomainP | cut -d: -f1)
upPort=$(echo $upDomainP | cut -d: -f2| grep '^[[:digit:]]*$')

xrayOutboundForward

systemctl restart vtrui >/dev/null 2>&1

blue "-----------------------"
blue  "Set XTLS Client [done]"
blue "-----------------------"

elif [[ $xtlsSet = "2" ]]; then
    green "======================="
    green "XTLS Port"
    green "======================="
    read xtlsPort

port=$(awk '/ssl http2 fastopen=128 reuseport/ {print$2}' /etc/nginx/conf.d/default.conf)
uuids=$(jq -r '.inbounds[0].settings.clients[].id' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')

xrayInboundForward

systemctl restart vtrui >/dev/null 2>&1

blue "-----------------------"
blue  "Set XTLS Server [done]"
blue "-----------------------"

elif [[ $xtlsSet = "3" ]]; then
jq 'del(.inbounds[] | select(.tag == "forward"))' /opt/de_GWD/vtrui/config.json | sponge /opt/de_GWD/vtrui/config.json
xrayOutboundDirect

systemctl restart vtrui >/dev/null 2>&1

blue "--------------------------"
blue  "Delete XTLS Client [done]"
blue "--------------------------"
fi
}



changeTCPPF(){
    green "============================"
    green "[1]: Set TCP Port Forward "
    green "[2]: Delete TCP Port Forward "
    green "============================"
    read -s -n 1 tcpPFsw

if [[ $tcpPFsw = "1" ]]; then
    green "======================="
    green "Upstream Domain & Port"
    green "======================="
    read upDomainP

    green "======================="
    green "Local Port"
    green "======================="
    read localP

upDomain=$(echo $upDomainP | cut -d: -f1)
upPort=$(echo $upDomainP | cut -d: -f2| grep '^[[:digit:]]*$')

unset aptPKG
[[ -z $(dpkg -l | awk '{print$2}' | grep '^haproxy$') ]] && aptPKG+=(haproxy)
[[ -n $aptPKG ]] && apt update && apt install $(echo ${aptPKG[@]})

cat << EOF >/etc/haproxy/haproxy.cfg
global
  ulimit-n              500000
  maxconn               200000

defaults
  mode                  tcp
  option                dontlognull
  timeout connect       10s
  timeout client        1m
  timeout server        1m
  timeout check         10s

resolvers local
  nameserver            dns 127.0.0.1:53
  resolve_retries       3
  timeout retry         3s
  hold valid            10s
  accepted_payload_size 8192

frontend $upDomain
  bind                  *:$localP
  default_backend       $upDomain

backend $upDomain
  server endpoint $upDomainP check resolvers local init-addr none
EOF


rm -rf /lib/systemd/system/haproxy.service
cat << "EOF" >/etc/systemd/system/haproxy.service
[Unit]
Description=HAProxy
After=network.target rsyslog.service

[Service]
Type=notify
EnvironmentFile=-/etc/default/haproxy
Environment="CONFIG=/etc/haproxy/haproxy.cfg" "PIDFILE=/run/haproxy.pid"
ExecStartPre=/usr/sbin/haproxy -f $CONFIG -c -q $EXTRAOPTS
ExecStart=/usr/sbin/haproxy -Ws -f $CONFIG -p $PIDFILE $EXTRAOPTS
ExecReload=/usr/sbin/haproxy -f $CONFIG -c -q $EXTRAOPTS
ExecReload=/bin/kill -USR2 $MAINPID
KillMode=mixed
Restart=on-failure
CapabilityBoundingSet=CAP_NET_RAW CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN CAP_NET_BIND_SERVICE
LimitNOFILE=1000000
LimitNPROC=infinity
LimitCORE=infinity
PrivateTmp=false
NoNewPrivileges=yes
Nice=-7

[Install]
WantedBy=multi-user.target
EOF

if [[ $virt_type == "container" ]]; then
sed -i '/Nice=/d' /etc/systemd/system/haproxy.service
fi
ls -sf /etc/systemd/system/haproxy.service /lib/systemd/system/haproxy.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null
systemctl restart haproxy
if [[ $? -ne 0 ]]; then
sed -i '/Nice=/d' /etc/systemd/system/haproxy.service
ls -sf /etc/systemd/system/haproxy.service /lib/systemd/system/haproxy.service >/dev/null 2>&1
systemctl daemon-reload >/dev/null
systemctl restart haproxy
fi
systemctl enable haproxy >/dev/null 2>&1

domain=$(awk '/server_name/ {print$2;exit}' /etc/nginx/conf.d/default.conf | sed 's/.$//')

blue "------------------------------------------------"
green "TCP Port Forward  "
echo
blue "Address:       $(yellow "$domain:$localP")"
blue "tls:           $(yellow "$upDomain")"
blue "------------------------------------------------"
echo
blue "----------------------------"
blue  "Set TCP Port Forward  [done]"
blue "----------------------------"
elif [[ $tcpPFsw = "2" ]]; then
systemctl stop haproxy
systemctl disable haproxy

rm -rf /etc/haproxy/haproxy.cfg >/dev/null 2>&1
blue "-------------------------------"
blue  "Delete TCP Port Forward  [done]"
blue "-------------------------------"
fi
}



printNode(){
vpsdomain=$(awk '/server_name/ {print$2;exit}' /etc/nginx/conf.d/default.conf | sed 's/.$//')
port=$(awk '/ssl http2 fastopen=128 reuseport/ {print$2}' /etc/nginx/conf.d/default.conf)

if [[ $port = "443" ]]; then
vpsdomainP=$vpsdomain
else
vpsdomainP=$vpsdomain:$port
fi

path=$(jq -r '.inbounds[0].streamSettings.wsSettings.path' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')
uuids=$(jq -r '.inbounds[0].settings.clients[].id' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')

xtlsPort=$(jq -r '.inbounds[] | select(.tag == "forward") | .port' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')

if [[ $(systemctl is-active 'haproxy') == "active" ]]; then
blue  "--------------------------------------------------"
green "HAProxy TCP Port Forward"
echo
awk '/frontend/' /etc/haproxy/haproxy.cfg | while read line
do
upDomain=$(echo $line | awk '{print$2}')
localPort=$(awk "/frontend $upDomain/{getline; print}" /etc/haproxy/haproxy.cfg | cut -d: -f2)
upDomainP=$(awk "/backend $upDomain/{getline; print\$3}" /etc/haproxy/haproxy.cfg)

blue "Address:       $(yellow "$vpsdomain:$localPort")"
blue "tls:           $(yellow "$upDomain")"
echo
done
fi

if [[ -n $xtlsPort ]]; then
blue  "--------------------------------------------------"
green "XTLS Server"
echo
blue "XTLS Port: $(yellow "$xtlsPort")"
echo
fi
blue  "--------------------------------------------------"
green "Xray node information"
echo
blue "DoH:       $(yellow "$vpsdomainP/dq")"
blue "Domain:    $(yellow "$vpsdomainP")"
blue "UUID:      $(yellow "$uuids")"
blue "Path:      $(yellow "$path?ed=2048")"
echo
blue "QR code:"
subAddr=$(echo -n "$(jq -r '.inbounds[0].settings.clients[0].id' /opt/de_GWD/vtrui/config.json 2>/dev/null | grep -v '^null$')@$vpsdomain:$port")
subUrl="vless://"$subAddr"?encryption=none&security=tls&sni="$vpsdomain"&type=ws&path="$path"&tfo=1&mux=1"
qrencode -t UTF8 -s 1 -m 3 $subUrl
echo
blue  "--------------------------------------------------"
}



installGWD(){
    green "=================="
    green " Input VPS domain"
    green "=================="
    read vpsdomainP

domain=$(echo $vpsdomainP | cut -d: -f1)
topDomain=$(echo $domain | rev | awk -F. '{print $1"."$2}' | rev)
port=$(echo $vpsdomainP | cut -d: -f2 | grep '^[[:digit:]]*$')
[[ -z $port ]] && port="443"

if [[ $port != "443" ]]; then
    green "==============================="
    green " Cloudflare API KEY"
    green "==============================="
    read CFapikey

    green "==============================="
    green " Cloudflare Email"
    green "==============================="
    read CFemail
fi

uuids=$(cat /proc/sys/kernel/random/uuid)
path="/$(echo $uuids | awk '{print substr($0,length($1)-5)}')"

ethernetnum=$(ip --oneline link show up | grep -v "lo" | awk '{print $2}' | cut -d':' -f1 | cut -d'@' -f1 | awk 'NR==1{print}')
ethernetnums=$(ip --oneline link show up | grep -v "lo" | awk '{print $2}' | cut -d':' -f1 | cut -d'@' -f1 | xargs | sed 's/ /,/g')
localaddr=$(ip -4 a | grep inet | grep -v 127.0.0 | awk '{print $2}' | cut -d'/' -f1 | head -n 1)

dpkg --configure -a

if [[ $(cat /etc/os-release | grep VERSION= | cut -d'(' -f2 | cut -d')' -f1) == "stretch" ]]; then
cat << EOF >/etc/apt/sources.list
deb http://cloudfront.debian.net/debian buster main contrib non-free
deb http://cloudfront.debian.net/debian buster-updates main contrib non-free
deb http://cloudfront.debian.net/debian-security buster/updates main contrib non-free
EOF

sed -i "s/ stretch / buster /g" /etc/apt/sources.list.d/* >/dev/null 2>&1
apt update --fix-missing && apt upgrade --allow-downgrades -y
apt full-upgrade -y && apt --purge autoremove -y && apt clean -y && apt autoclean -y
fi

cat << EOF >/etc/apt/sources.list
deb http://cloudfront.debian.net/debian bullseye main contrib non-free
deb http://cloudfront.debian.net/debian bullseye-updates main contrib non-free
deb http://cloudfront.debian.net/debian bullseye-backports main contrib non-free
deb http://cloudfront.debian.net/debian-security bullseye-security main contrib non-free
EOF

sed -i "s/ buster / bullseye /g" /etc/apt/sources.list.d/* >/dev/null 2>&1
apt update --fix-missing && apt upgrade --allow-downgrades -y
apt full-upgrade -y && apt --purge autoremove -y && apt clean -y && apt autoclean -y

preInstall

installPihole

piholeSet

[[ $virt_type != "container" ]] && installNftables

repoDL

installDOH

installNginx

installXray

if [[ $port == "443" ]]; then
makeSSL_W
else
makeSSL_D
fi

ocspStapling

nginxWebConf

xrayInbound

xrayOutboundDirect

postInstall

enableAutoUpdate

printNode

blue "----------------------"
blue  "Install de_GWD [done]"
blue "----------------------"
}



updateGWD(){
[[ ! -f "/opt/de_GWD/version.php" ]] && red "this is not server" && exit

preUpdate

preInstall

installPihole

piholeSet

[[ $virt_type != "container" ]] && installNftables

repoDL

installDOH

installNginx

installXray

nginxWebConf

xrayInbound

if [[ -n $xtlsPort ]]; then
  xrayInboundForward
fi

if [[ -n $upDomain ]]; then
  xrayOutboundForward
else
  xrayOutboundDirect
fi

postInstall

blue "---------------------"
blue  "Update de_GWD [done]"
blue "---------------------"

checkKernel
}



enableAutoUpdate(){
cat << "EOF" >/opt/de_GWD/autoUpdate
#!/bin/bash
localVer=$(awk 'NR==1' /opt/de_GWD/version.php)
remoteVer=$(curl -fsSLo- https://raw.githubusercontent.com/jacyl4/de_GWD/main/version.php | head -n 1)

echo $localVer >/tmp/de_GWD_Ver
echo $remoteVer >>/tmp/de_GWD_Ver

VerCP=$(cat /tmp/de_GWD_Ver | sort -rV | uniq | awk NR==2)

if [[ $VerCP == $localVer ]]; then
rm -rf /tmp/autoUpdate
wget -t 5 -T 10 -cqO /tmp/autoUpdate https://raw.githubusercontent.com/jacyl4/de_GWD/main/server

if [[ $(du -sk /tmp/autoUpdate 2>/dev/null | awk '{print$1}') -gt 70 ]]; then
sed -i '$d' /tmp/autoUpdate
echo "updateGWD" >>  /tmp/autoUpdate
chmod +x /tmp/autoUpdate
/tmp/autoUpdate
rm -rf /tmp/autoUpdate
fi
fi

rm -rf /tmp/de_GWD_Ver
rm -rf /tmp/autoUpdate
EOF
chmod +x /opt/de_GWD/autoUpdate

crontab -l 2>/dev/null > /tmp/now.cron
sed -i '/autoUpdate/d' /tmp/now.cron
echo '30 4 * * *  /opt/de_GWD/autoUpdate' >> /tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron
}



autoUpdateGWD(){
    green "========================"
    green "[Y]: Turn on AutoUpdate"
    green "[N]: Turn off AutoUpdate"
    green "========================"
    read -s -n 1 autoUpdateswitch
echo
if [[ $autoUpdateswitch = "Y" ]] || [[ $autoUpdateswitch = "y" ]]; then

enableAutoUpdate

blue "--------------------------"
blue  "AutoUpdate turn on [done]"
blue "--------------------------"

elif [[ $autoUpdateswitch = "N" ]] || [[ $autoUpdateswitch = "n" ]]; then

crontab -l 2>/dev/null > /tmp/now.cron
sed -i '/autoUpdate/d' /tmp/now.cron
crontab /tmp/now.cron
rm -rf /tmp/now.cron

rm -rf /opt/de_GWD/autoUpdate
blue "---------------------------"
blue  "AutoUpdate turn off [done]"
blue "---------------------------"
fi
}




start_menu(){
if [[ $(systemctl is-active 'pihole-FTL') == "active" ]]; then
    echo "[$statusGOOD] Pi-hole        [working]"
elif [ ! -f "/usr/local/bin/pihole" ]; then
    echo "[$statusBAD] Pi-hole        [not installed]"
else
    echo "[$statusBAD] Pi-hole        [start failed]"
fi

if [[ $(systemctl is-active 'nginx') == "active" ]]; then
    echo "[$statusGOOD] Nginx          [working]"
elif [[ ! -f "/usr/sbin/nginx" ]]; then
    echo "[$statusBAD] Nginx          [not installed]"
else
    echo "[$statusBAD] Nginx          [start failed]"
fi

if [[ $(systemctl is-active 'vtrui') == "active" ]]; then
    echo "[$statusGOOD] Xray           [working]"
elif [[ ! -d "/opt/de_GWD/vtrui" ]]; then
    echo "[$statusBAD] Xray           [not Installed]"
else
    echo "[$statusBAD] Xray           [start failed]"
fi

if [[ $(systemctl is-active 'doh-server') == "active" ]]; then
    echo "[$statusGOOD] DoH server     [working]"
elif [[ ! -f "/opt/de_GWD/doh-server" ]]; then
    echo "[$statusBAD] DoH server     [not Installed]"
else
    echo "[$statusBAD] DoH server     [start failed]"
fi

if [[ -n $(crontab -l 2>&1 | grep "autoUpdate") ]] && [[ -f "/opt/de_GWD/autoUpdate" ]]; then
    echo "[$statusGOOD] AutoUpdate     [working] (4:30 AM)"
else
    echo "[$statusNONE] AutoUpdate     [stopped]"
fi

blue  $virt
[[ -f "/opt/de_GWD/version.php" ]] && blue "Version:$(echo $(awk 'NR==1' /opt/de_GWD/version.php))"
[[ $(systemctl is-active 'wg-quick@wgcf') == "active" ]] && purple "[Enabled] Cloudflare wireguard upstream (WARP)"
[[ $(systemctl is-active 'haproxy') == "active" ]] && purple "[Enabled] HAProxy TCP Port Forward"

if [[ $virt_type == "container" ]]; then
    blue  "--------------------------------------------------"
    blue  "Debian Version:                 $(cat /etc/os-release | grep VERSION= | cut -d'(' -f2 | cut -d')' -f1)"
    blue  "Kernel:                         $(uname -r)"
    blue  "--------------------------------------------------"
    green "============SERVER================================"
    green "       __         _______       ______  "
    green "  ____/ /__      / ____/ |     / / __ \ "
    green " / __  / _ \    / / __ | | /| / / / / / "
    green "/ /_/ /  __/   / /_/ / | |/ |/ / /_/ /  "
    green "\__,_/\___/____\____/  |__/|__/_____/   "
    green "         /_____/                        "
    echo
    green "Require: Debian (amd64 && arm64)"
    green "Author:  JacyL4"
    green "=================================================="
    echo
    green  "1. Install de_GWD"
    green  "2. Install lkl-bbrplus"
    red    "4. Change domain and generate new certificate"
    red    "5. Change Xray path & UUID"
    yellow "6. Change XTLS Forward"
    yellow "0. Update de_GWD"
    red    "00.AutoUpdate turn on/off"
    green  "11.Print Xray node information"
    cyan   "44.Set TCP Port Forward "
    red    "CTRL+C EXIT"
    echo
    read -p "Select:" num
    case "$num" in
    1)
    installGWD
    start_menu
    ;;
    2)
    installBBRplus
    start_menu
    ;;
    4)
    changeDomain
    start_menu
    ;;
    5)
    changeXrayVerify
    start_menu
    ;;
    6)
    changeXTLSF
    start_menu
    ;;
    0)
    updateGWD
    start_menu
    ;;
    00)
    autoUpdateGWD
    start_menu
    ;;
    11)
    printNode
    start_menu
    ;;
    44)
    changeTCPPF
    start_menu
    ;;
    *)
    clear
    red "Wrong number"
    sleep 1s
    start_menu
    ;;
    esac

else
    blue  "--------------------------------------------------"
    blue  "Debian Version:                 $(cat /etc/os-release | grep VERSION= | cut -d'(' -f2 | cut -d')' -f1)"
    blue  "Kernel:                         $(uname -r)"
    blue  "Current tcp congestion control: $(sysctl net.ipv4.tcp_congestion_control 2>/dev/null | cut -d' ' -f3) + $(sysctl net.core.default_qdisc 2>/dev/null | cut -d' ' -f3)"
    blue  "--------------------------------------------------"
    green "============SERVER================================"
    green "       __         _______       ______  "
    green "  ____/ /__      / ____/ |     / / __ \ "
    green " / __  / _ \    / / __ | | /| / / / / / "
    green "/ /_/ /  __/   / /_/ / | |/ |/ / /_/ /  "
    green "\__,_/\___/____\____/  |__/|__/_____/   "
    green "         /_____/                        "
    echo
    green "Require: Debian (amd64 && arm64)"
    green "Author:  JacyL4"
    green "=================================================="
    echo
    green  "1. Install de_GWD"
    green  "2. Install BBRplus-$BBRPLUS_Ver / Liquorix / XanMod kernel and reboot"
    blue   "3. Restore default kernel and reboot"
    red    "4. Change domain and generate new certificate"
    red    "5. Change Xray path & UUID"
    yellow "6. Change XTLS Forward"
    yellow "0. Update de_GWD"
    red    "00.AutoUpdate turn on/off"
    green  "11.Print Xray node information"
    cyan   "33.Set Cloudflare wireguard upstream (WARP)"
    cyan   "44.Set TCP Port Forward "
    red    "CTRL+C EXIT"
    echo
    read -p "Select:" num
    case "$num" in
    1)
    installGWD
    start_menu
    ;;
    2)
    install3rdKernel
    start_menu
    ;;
    3)
    restoreKernel
    start_menu
    ;;
    4)
    changeDomain
    start_menu
    ;;
    5)
    changeXrayVerify
    start_menu
    ;;
    6)
    changeXTLSF
    start_menu
    ;;
    0)
    updateGWD
    start_menu
    ;;
    00)
    autoUpdateGWD
    start_menu
    ;;
    11)
    printNode
    start_menu
    ;;
    33)
    changeWGCF
    start_menu
    ;;
    44)
    changeTCPPF
    start_menu
    ;;
    *)
    clear
    red "Wrong number"
    sleep 1s
    start_menu
    ;;
    esac
fi
}

start_menu